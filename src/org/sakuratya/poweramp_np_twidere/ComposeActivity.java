package org.sakuratya.poweramp_np_twidere;

import java.io.File;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.IOException;

import org.mariotaku.twidere.Constants;
import com.maxmpz.audioplayer.player.PowerAMPiAPI;

import android.net.Uri;
import android.os.AsyncTask;
import android.os.Bundle;
import android.os.Environment;
import android.os.Handler;
import android.preference.PreferenceManager;
import android.provider.MediaStore;
import android.app.Activity;
import android.content.BroadcastReceiver;
import android.content.Context;
import android.content.Intent;
import android.content.IntentFilter;
import android.content.SharedPreferences;
import android.content.SharedPreferences.OnSharedPreferenceChangeListener;
import android.graphics.Bitmap;
import android.graphics.BitmapFactory;
import android.text.TextUtils;
import android.util.Log;
import android.view.Menu;
import android.view.View;
import android.view.View.OnClickListener;
import android.widget.Button;
import android.widget.CheckBox;
import android.widget.CompoundButton.OnCheckedChangeListener;
import android.widget.CompoundButton;
import android.widget.ImageView;
import android.widget.TextView;
import android.widget.Toast;

public class ComposeActivity extends Activity implements OnSharedPreferenceChangeListener {
	private final static String TAG = "ComposeActivity";
	private final static String DESCRIPTION = "Generated by PowerAMP NP Plugin For Twidere";
	
	private final static int ALBUMART_HANDLE_DECODE_MODE = 0;
	private final static int ALBUMART_HANDLE_SAVEFILE_MODE = 1;
	/**
	 * Track info.
	 */
	private String mTrackTitle ;
	private String mTrackArtist;
	private String mTrackAlbum;
	private Uri mAlbumArtUri;

	/** 
	 * Previews widget.
	 */
	private TextView mTrackTitlePreview;
	private TextView mTrackArtistPreview;
	private TextView mTrackAlbumPreview;
	private TextView mTextPendingPreview;
	private ImageView mAlbumArtPreview;
	private Button mAppendNPTextButton;
	private CheckBox mInsertAlbumArt;

	/**
	 * Pending text which will append to tweet.
	 */
	private String mTextPending;
	
	private SharedPreferences mPreferences;
	
	/**
	 * When set to false. all previews widget will not show. This activity skip and auto append np text to tweet.
	 */
	private boolean isPreviewEnabled = true;
	/**
	 * If enabled, album art will shown in the preview imageview. if isPreviewEnabled is false. this activity will show until image's uri is gained and auto finish.
	 */
	private boolean isAlbumArtEnabled = false;
	/**
	 * Identify if track info has been gained.
	 */
	private boolean isTrackInfoRead = false;
	
	private boolean isAlbumInfoRead = false;
	
	private Bitmap.CompressFormat  mAlbumArtFormat;
	
	private int mCompressQuality = 100;
	
    @Override
    public void onCreate(Bundle savedInstanceState) {
        super.onCreate(savedInstanceState);

        mPreferences  = PreferenceManager.getDefaultSharedPreferences(this);
        
        // Read the preference.
        mTextPending = mPreferences.getString(SettingsActivity.SETTING_NP_TEXT_FORMAT, "");
        isPreviewEnabled = mPreferences.getBoolean(SettingsActivity.SETTING_SHOW_PREVIEW, true);
        isAlbumArtEnabled = mPreferences.getBoolean(SettingsActivity.SETTING_INSERT_ALBUMART, false);
        String albumArtFormat = mPreferences.getString(SettingsActivity.SETTING_ALBUMART_FORMAT, "jpeg");
        if("jpeg".equals(albumArtFormat)) {
        	mAlbumArtFormat = Bitmap.CompressFormat.JPEG;
        } else if("png".equals(albumArtFormat)) {
        	mAlbumArtFormat = Bitmap.CompressFormat.PNG;
        }
        if(isPreviewEnabled) {
        	setContentView(R.layout.activity_compose);
            
            mTrackTitlePreview = (TextView) findViewById(R.id.track_title);
            mTrackArtistPreview = (TextView) findViewById(R.id.track_artist);
            mTrackAlbumPreview = (TextView) findViewById(R.id.track_album);
            mTextPendingPreview = (TextView) findViewById(R.id.text_pending);
            mAlbumArtPreview = (ImageView) findViewById(R.id.album_art_preview);
            
            mInsertAlbumArt = (CheckBox) findViewById(R.id.insert_albumart);
            mInsertAlbumArt.setOnCheckedChangeListener(mChangeListener);
            mInsertAlbumArt.setChecked(isAlbumArtEnabled);
            mAppendNPTextButton = (Button) findViewById(R.id.append_np_text);
            mAppendNPTextButton.setOnClickListener(mOnClickListener);
            mAlbumArtPreview.setVisibility(View.VISIBLE);
            if(isAlbumArtEnabled) {
            	mAppendNPTextButton.setText(R.string.wait_for_loading);
            	mAppendNPTextButton.setEnabled(false);
            }
        }
        
        registerAndLoadStatus();
    }
    
    private void registerAndLoadStatus() {
    	registerReceiver(mTrackReceiver, new IntentFilter(PowerAMPiAPI.ACTION_TRACK_CHANGED));
    	registerReceiver(mAAReceiver, new IntentFilter(PowerAMPiAPI.ACTION_AA_CHANGED));
    }
    
    private OnCheckedChangeListener mChangeListener = new OnCheckedChangeListener() {
		
		@Override
		public void onCheckedChanged(CompoundButton buttonView, boolean isChecked) {
			if(isChecked) {
				isAlbumArtEnabled = true;
			} else {
				isAlbumArtEnabled = false;
			}
		}
	};
    
    private OnClickListener mOnClickListener = new OnClickListener() {
		
		@Override
		public void onClick(View v) {
			int id = v.getId();
			switch(id){
			case R.id.append_np_text:
//				Twidere.appendComposeActivityText(ComposeActivity.this, mTextPending);
				// Because of the twidere extension library has not update to support insert image uri. but twidere has already support this
				appendInfoAndFinish();
				break;
			}
		}
	};
	
	private void appendInfoAndFinish() {
		final Intent intent = new Intent();
		final Bundle extras = new Bundle();
		extras.putString(Constants.INTENT_KEY_APPEND_TEXT, mTextPending);
		if(isAlbumArtEnabled && mAlbumArtUri!=null) {
			extras.putParcelable(Constants.INTENT_KEY_IMAGE_URI, mAlbumArtUri);
		}
		intent.putExtras(extras);
		ComposeActivity.this.setResult(Activity.RESULT_OK, intent);
		ComposeActivity.this.finish();
	}
	
	private void checkIfCanAppend() {
		mCheckTaskHandler.post(mCheckTaskRunnable);
	}
	
	private Handler mCheckTaskHandler = new Handler();
	
	private Runnable mCheckTaskRunnable = new Runnable() {

		@Override
		public void run() {
			if(isPreviewEnabled) {
				if(isAlbumArtEnabled) {
					if(isAlbumInfoRead && isTrackInfoRead) {
						mAppendNPTextButton.setText(R.string.append_text);
						mAppendNPTextButton.setEnabled(true);
					} else {
						mCheckTaskHandler.postDelayed(mCheckTaskRunnable, 100);
					}
				} else {
					if(isTrackInfoRead) {
						mAppendNPTextButton.setText(R.string.append_text);
						mAppendNPTextButton.setEnabled(true);
					} else {
						mCheckTaskHandler.postDelayed(mCheckTaskRunnable, 100);
					}
				}
			} else {
				if(isAlbumArtEnabled) {
					if(isAlbumInfoRead && isTrackInfoRead) {
						mAppendNPTextButton.setText(R.string.append_text);
						appendInfoAndFinish();
					} else {
						mCheckTaskHandler.postDelayed(mCheckTaskRunnable, 100);
					}
				} else {
					if(isTrackInfoRead) {
						mAppendNPTextButton.setText(R.string.append_text);
						appendInfoAndFinish();
					} else {
						mCheckTaskHandler.postDelayed(mCheckTaskRunnable, 100);
					}
				}
			}
		}
		
	};

    @Override
    public boolean onCreateOptionsMenu(Menu menu) {
        getMenuInflater().inflate(R.menu.activity_main, menu);
        return true;
    }
    
    private BroadcastReceiver mTrackReceiver = new BroadcastReceiver() {
		
		@Override
		public void onReceive(Context context, Intent intent) {
			Bundle currentTrack = intent.getBundleExtra(PowerAMPiAPI.TRACK);
			if(currentTrack!=null) {
				updateTrackInfo(currentTrack);
			}
		}
	};
	
	private BroadcastReceiver mAAReceiver = new BroadcastReceiver() {
		
		@Override
		public void onReceive(Context context, Intent intent) {
			updateAlbumArt(intent);
		}
	};
	
	/**
	 * Update track info from give Bundle
	 * @param track bundle contains trackinfo.
	 */
	private void updateTrackInfo(Bundle track) {
		mTrackTitle = track.getString(PowerAMPiAPI.Track.TITLE);
		mTrackArtist = track.getString(PowerAMPiAPI.Track.ARTIST);
		mTrackAlbum = track.getString(PowerAMPiAPI.Track.ALBUM);
		Log.d(TAG, "mTrackTitle: "+ mTrackTitle);
		Log.d(TAG, "mTrackArtist: "+ mTrackArtist);
		Log.d(TAG, "mTrackAlbum: "+ mTrackAlbum);
		isTrackInfoRead = true;
		updatePendingText();
		mTrackTitlePreview.setText(mTrackTitle);
		mTrackArtistPreview.setText(mTrackArtist);
		mTrackAlbumPreview.setText(mTrackAlbum);
		mTextPendingPreview.setText(mTextPending);
		if(!isPreviewEnabled) {
			checkIfCanAppend();
		}
	}
	
	private void updateAlbumArt(Intent intent) {
		String albumArtPath = intent.getStringExtra(PowerAMPiAPI.ALBUM_ART_PATH);
		if(!TextUtils.isEmpty(albumArtPath)) {
			mAlbumArtUri = Uri.parse(albumArtPath);
			isAlbumInfoRead = true;
			if(isPreviewEnabled) {
				new AlbumArtHandleTask().execute(ALBUMART_HANDLE_DECODE_MODE);
			} else {
				checkIfCanAppend();
			}
			
		} else if(intent.hasExtra(PowerAMPiAPI.ALBUM_ART_BITMAP)) {
			Bitmap albumArtBitmap = intent.getParcelableExtra(PowerAMPiAPI.ALBUM_ART_BITMAP);
			new AlbumArtHandleTask().execute(ALBUMART_HANDLE_SAVEFILE_MODE, albumArtBitmap);
		} else {
			if(!isPreviewEnabled ) {
				isAlbumInfoRead = true;
				checkIfCanAppend();
			}
		}
	}
	
	class AlbumArtHandleTask extends AsyncTask<Object, Void, Bitmap> {

		private int mode;
		
		@Override
		protected Bitmap doInBackground(Object... params) {
			mode = (Integer) params[0];
			if(mode==ALBUMART_HANDLE_DECODE_MODE) {
				String filePath = (String) params[1];
				return BitmapFactory.decodeFile(filePath);
			} else {
				Bitmap bmp = (Bitmap) params[1];
				String externalState = Environment.getExternalStorageState();
				Log.d(TAG, "externalState="+externalState);
				String url  = null;
				if(Environment.MEDIA_MOUNTED.equals(externalState)) {
					File path = Environment.getExternalStorageDirectory();
					String cachePath = path.getAbsolutePath() + "/sakuratya/pnt/";
					Log.d(TAG, "cachePath="+cachePath);
					File cache = new File(cachePath);
					if(!cache.exists()){
						if(!cache.mkdirs()){
							url = MediaStore.Images.Media.insertImage(getContentResolver(), bmp, mTrackAlbum, DESCRIPTION);
							if(url!=null) {
								Log.d(TAG, "url=" + url);
								mAlbumArtUri = Uri.parse(url);
							}
							return bmp;
						}
					}
					File[] files = cache.listFiles();
					if(files!=null && files.length > 0) {
						for(File file:files) {
							file.delete();
						}
					}
					FileOutputStream out = null;
					try {
						long currentTime = System.currentTimeMillis();
						String ext = mAlbumArtFormat == Bitmap.CompressFormat.JPEG ? ".jpg": ".png";
						File imgFile = new File(cachePath + "/" + currentTime +ext);
						out = new FileOutputStream(imgFile);
						if(bmp.compress(mAlbumArtFormat, mCompressQuality, out)){
							url = imgFile.getAbsolutePath();
						} else {
							url = MediaStore.Images.Media.insertImage(getContentResolver(), bmp, mTrackAlbum, DESCRIPTION);
						}
					} catch (FileNotFoundException e) {
						// TODO Auto-generated catch block
						e.printStackTrace();
					} finally {
						try {
							if(out!=null) {
								out.flush();
								out.close();
							}
						} catch (IOException e) {
							// TODO Auto-generated catch block
							e.printStackTrace();
						}
					}
				} else {
					Toast.makeText(ComposeActivity.this, R.string.sd_not_found, Toast.LENGTH_SHORT).show();
				}
				
				if(url!=null) {
					Log.d(TAG, "url=" + url);
					mAlbumArtUri = Uri.parse(url);
				}
				return bmp;
			}
		}

		@Override
		protected void onPostExecute(Bitmap result) {
			if(result!=null) {
				mAlbumArtPreview.setImageBitmap(result);
			}
			isAlbumInfoRead = true;
			checkIfCanAppend();
		}
		
	}
	
	/**
	 * Update {@link #mTextPending} with give track info and np text format from preference.
	 */
	private void updatePendingText() {
		if(!TextUtils.isEmpty(mTextPending)) {
			mTextPending = mTextPending.replace("[title]", mTrackTitle).replace("[artist]", mTrackArtist).replace("[album]", mTrackAlbum);
		} else {
			Toast.makeText(this, R.string.error_loading_text, Toast.LENGTH_SHORT).show();
		}
	}

	@Override
	protected void onDestroy() {
		unregisterReceiver(mTrackReceiver);
		unregisterReceiver(mAAReceiver);
		mCheckTaskHandler.removeCallbacks(mCheckTaskRunnable);
		super.onDestroy();
	}

	@Override
	public void onSharedPreferenceChanged(SharedPreferences sharedPreferences,
			String key) {
		// When preference has changed, we need to update pending text with new format.
		// Usually this will not occur.
		if(SettingsActivity.SETTING_NP_TEXT_FORMAT.equals(key)) {
			mTextPending = sharedPreferences.getString(SettingsActivity.SETTING_NP_TEXT_FORMAT, "");
			if(isTrackInfoRead) {
				updatePendingText();
				if(isPreviewEnabled) {
					mTextPendingPreview.setText(mTextPending);
				}
			}
		}
	}
	
	
}
